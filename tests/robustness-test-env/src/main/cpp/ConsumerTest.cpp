/*
 * #%L
 * %%
 * Copyright (C) 2018 BMW Car IT GmbH
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */

#include "ConsumerTest.h"

#include "joynr/MulticastSubscriptionQos.h"
#include "joynr/OnChangeSubscriptionQos.h"
#include "joynr/SubscriptionListener.h"
#include "joynr/tests/robustness/MySubscriptionContainer.h"
#include "joynr/types/ProviderQos.h"

constexpr std::size_t validityOfBroadcastSubscriptionDurationMs = 60 * 1000;
constexpr std::size_t validityOfSelectiveBroadcastSubscriptionDurationMs = 180 * 1000;
constexpr std::size_t setMinimumIntervalSelectiveBroadcastMs = 2 * 1000;
constexpr std::size_t qosMsgTimeToLiveMs = 30000;
constexpr std::size_t discoveryTimeoutMs = 40000;
constexpr std::size_t subscriptionIdFutureDefault = 2000;

// A class that listens to messages generated by subscriptions
class MyBroadcastListener
        : public joynr::SubscriptionListener<joynr::tests::robustness::MySubscriptionContainer>
{
public:
    MyBroadcastListener() = default;

    ~MyBroadcastListener() = default;

    void onSubscribed(const std::string& subscriptionId)
    {
        JOYNR_LOG_INFO(logger(), "--------------------------------------------------");
        JOYNR_LOG_INFO(
                logger(), "BROADCAST SUBSCRIPTION successful, subscriptionId: {}", subscriptionId);
        JOYNR_LOG_INFO(logger(), "--------------------------------------------------");
    }

    void onReceive(const joynr::tests::robustness::MySubscriptionContainer& value)
    {
        JOYNR_LOG_INFO(logger(), "--------------------------------------------------");
        JOYNR_LOG_INFO(logger(), "BROADCAST SUBSCRIPTION : {}", value.toString());
        JOYNR_LOG_INFO(logger(), "--------------------------------------------------");
    }

private:
    ADD_LOGGER(MyBroadcastListener)
};

ConsumerTest::ConsumerTest(const ConsumerTestParameters& params) : testParams(params)
{
    JOYNR_LOG_TRACE(logger(), "constructor");
}

ConsumerTest::~ConsumerTest()
{
    JOYNR_LOG_TRACE(logger(), "destructor");
}

void ConsumerTest::init()
{
    JOYNR_LOG_TRACE(logger(), "initialisation started");

    // onFatalRuntimeError callback is optional, but it is highly recommended to provide an
    // implementation.
    std::function<void(const joynr::exceptions::JoynrRuntimeException&)> onFatalRuntimeError =
            [&](const joynr::exceptions::JoynrRuntimeException& exception) {
        JOYNR_LOG_ERROR(
                logger(), "Unexpected joynr runtime error occured: " + exception.getMessage());
    };

    // Initialize the joynr runtimes
    for (int i = 0; i < testParams.numOfRuntimes; i++) {
        runTimeContainer runTimeContainerTmp;
        runTimeContainerTmp.runtime =
                joynr::JoynrRuntime::createRuntime(testParams.pathToLibJoynrSettings,
                                                   onFatalRuntimeError,
                                                   testParams.pathToMessagingSettings);
        myRunTimeContainerList.emplace_back(std::move(runTimeContainerTmp));
    }

    // Create proxy builders
    for (int iRunTimeCount = 0; iRunTimeCount < testParams.numOfRuntimes; iRunTimeCount++) {
        for (int iProxyBuilder = 0; iProxyBuilder < testParams.numOfProxyBuilders;
             iProxyBuilder++) {
            proxyBuilderContainer proxyBuilderContainerTmp;
            proxyBuilderContainerTmp.proxyBuilder =
                    myRunTimeContainerList[iRunTimeCount]
                            .runtime
                            ->createProxyBuilder<joynr::tests::robustness::TestInterfaceProxy>(
                                    testParams.providerDomain);
            myRunTimeContainerList[iRunTimeCount].proxyBuilderContainerList.emplace_back(
                    std::move(proxyBuilderContainerTmp));
        }
    }

    // Messaging Quality of service
    std::int64_t qosMsgTtl = qosMsgTimeToLiveMs;
    joynr::DiscoveryQos discoveryQos;
    discoveryQos.setDiscoveryTimeoutMs(discoveryTimeoutMs);
    discoveryQos.setCacheMaxAgeMs(std::numeric_limits<std::int64_t>::max());
    discoveryQos.setArbitrationStrategy(joynr::DiscoveryQos::ArbitrationStrategy::HIGHEST_PRIORITY);
    discoveryQos.setDiscoveryScope(joynr::types::DiscoveryScope::GLOBAL_ONLY);

    // register the runtimes and subscribe
    for (int iRunTimeCount = 0; iRunTimeCount < testParams.numOfRuntimes; iRunTimeCount++) {
        for (int iProxyBuilder = 0; iProxyBuilder < testParams.numOfProxyBuilders;
             iProxyBuilder++) {
            for (int iProxy = 0; iProxy < testParams.numOfProxies; iProxy++) {
                // register the runtimes
                proxyContainer proxyContainerTmp;
                proxyContainerTmp.proxy =
                        myRunTimeContainerList[iRunTimeCount]
                                .proxyBuilderContainerList[iProxyBuilder]
                                .proxyBuilder->setMessagingQos(joynr::MessagingQos(qosMsgTtl))
                                ->setDiscoveryQos(discoveryQos)
                                ->build();
                proxyContainerTmp.myProxy = std::make_unique<ConsumerProxy>(
                        *(proxyContainerTmp.proxy), testParams.threadDelayMS);

                // subscribe to broadcaster 1
                auto myBroadcastSubscriptionQos1 =
                        std::make_shared<joynr::MulticastSubscriptionQos>();
                myBroadcastSubscriptionQos1->setValidityMs(
                        validityOfBroadcastSubscriptionDurationMs);
                auto myBroadcastListener1 = std::make_shared<MyBroadcastListener>();
                std::shared_ptr<joynr::Future<std::string>> myBroadcastSubscriptionIdFuture1;
                myBroadcastSubscriptionIdFuture1 =
                        proxyContainerTmp.proxy->subscribeToBroadcastWithClassParameter1Broadcast(
                                myBroadcastListener1, myBroadcastSubscriptionQos1);
                myBroadcastSubscriptionIdFuture1->get(
                        subscriptionIdFutureDefault, proxyContainerTmp.myBroadcastSubscriptionId1);

                // subscribe to broadcaster 2
                auto myBroadcastSubscriptionQos2 =
                        std::make_shared<joynr::MulticastSubscriptionQos>();
                myBroadcastSubscriptionQos2->setValidityMs(
                        validityOfBroadcastSubscriptionDurationMs);
                auto myBroadcastListener2 = std::make_shared<MyBroadcastListener>();
                std::shared_ptr<joynr::Future<std::string>> myBroadcastSubscriptionIdFuture2;
                myBroadcastSubscriptionIdFuture2 =
                        proxyContainerTmp.proxy->subscribeToBroadcastWithClassParameter2Broadcast(
                                myBroadcastListener2, myBroadcastSubscriptionQos2);
                myBroadcastSubscriptionIdFuture2->get(
                        subscriptionIdFutureDefault, proxyContainerTmp.myBroadcastSubscriptionId2);

                // subscribe to selective broadcaster 1
                auto mySelectiveBroadcastSubscriptionQos1 =
                        std::make_shared<joynr::OnChangeSubscriptionQos>();
                mySelectiveBroadcastSubscriptionQos1->setMinIntervalMs(
                        setMinimumIntervalSelectiveBroadcastMs);
                mySelectiveBroadcastSubscriptionQos1->setValidityMs(
                        validityOfSelectiveBroadcastSubscriptionDurationMs);
                auto mySelectiveBroadcastFilterParams1 = std::make_shared<
                        joynr::tests::robustness::
                                TestInterfaceBroadcastSelectiveWithSingleStringParameter1BroadcastFilterParameters>();
                mySelectiveBroadcastFilterParams1->setFilterParameter(
                        proxyContainerTmp.filterParamKey1, proxyContainerTmp.filterParamValue1);
                std::shared_ptr<joynr::ISubscriptionListener<std::string>>
                        mySelectiveBroadcastListener1;
                std::shared_ptr<joynr::Future<std::string>>
                        mySelectiveBroadcastSubscriptionIdFuture1;
                mySelectiveBroadcastSubscriptionIdFuture1 =
                        proxyContainerTmp.proxy
                                ->subscribeToBroadcastSelectiveWithSingleStringParameter1Broadcast(
                                        *mySelectiveBroadcastFilterParams1,
                                        mySelectiveBroadcastListener1,
                                        mySelectiveBroadcastSubscriptionQos1);
                mySelectiveBroadcastSubscriptionIdFuture1->get(
                        subscriptionIdFutureDefault,
                        proxyContainerTmp.mySelectiveBroadcastSubscriptionId1);

                // subscribe to selective broadcaster 2
                auto mySelectiveBroadcastSubscriptionQos2 =
                        std::make_shared<joynr::OnChangeSubscriptionQos>();
                mySelectiveBroadcastSubscriptionQos2->setMinIntervalMs(
                        setMinimumIntervalSelectiveBroadcastMs);
                mySelectiveBroadcastSubscriptionQos2->setValidityMs(
                        validityOfSelectiveBroadcastSubscriptionDurationMs);
                auto mySelectiveBroadcastFilterParams2 = std::make_shared<
                        joynr::tests::robustness::
                                TestInterfaceBroadcastSelectiveWithSingleStringParameter2BroadcastFilterParameters>();
                mySelectiveBroadcastFilterParams2->setFilterParameter(
                        proxyContainerTmp.filterParamKey2, proxyContainerTmp.filterParamValue2);
                std::shared_ptr<joynr::ISubscriptionListener<std::string>>
                        mySelectiveBroadcastListener2;
                std::shared_ptr<joynr::Future<std::string>>
                        mySelectiveBroadcastSubscriptionIdFuture2;
                mySelectiveBroadcastSubscriptionIdFuture2 =
                        proxyContainerTmp.proxy
                                ->subscribeToBroadcastSelectiveWithSingleStringParameter2Broadcast(
                                        *mySelectiveBroadcastFilterParams2,
                                        mySelectiveBroadcastListener2,
                                        mySelectiveBroadcastSubscriptionQos2);
                mySelectiveBroadcastSubscriptionIdFuture1->get(
                        subscriptionIdFutureDefault,
                        proxyContainerTmp.mySelectiveBroadcastSubscriptionId2);

                // save
                myRunTimeContainerList[iRunTimeCount]
                        .proxyBuilderContainerList[iProxyBuilder]
                        .proxyContainerList.emplace_back(std::move(proxyContainerTmp));
            }
        }
    }

    runTests();

    JOYNR_LOG_TRACE(logger(), "initialisation complete");
}

void ConsumerTest::runTests()
{
    for (const auto& it_runtime : myRunTimeContainerList) {
        for (const auto& it_proxyBuilder : it_runtime.proxyBuilderContainerList) {
            for (const auto& it_proxy : it_proxyBuilder.proxyContainerList) {
                it_proxy.myProxy->start();
            }
        }
    }
}

void ConsumerTest::stopTests()
{
    for (const auto& it_runtime : myRunTimeContainerList) {
        for (const auto& it_proxyBuilder : it_runtime.proxyBuilderContainerList) {
            for (const auto& it_proxy : it_proxyBuilder.proxyContainerList) {
                it_proxy.myProxy->stop();
            }
        }
    }
}

void ConsumerTest::shutDown(unsigned int testCase)
{
    // shutdown depending on the selected test case
    switch (testCase) {
    case testCaseType::TEST_1:
        // Run provider and consumer applications, then after a selected init time in the consumer
        // - the 2 threads calling methods shall be gracefully stopped and joined
        // - unsubcribe shall be done on the established broadcast- and attribute subscriptions
        // - proxies shall be destructed
        // - proxybuilders shall be destructed
        // - runtimes shall be destructed

        JOYNR_LOG_INFO(logger(), "Exit: Test case 1");

        stopTests();
        unsubscribeFromAll();
        destroyAllProxies();
        destroyAllProxyBuilders();
        destroyAllRuntimes();
        destroyAllContainers();
        break;
    case testCaseType::TEST_2:
        // Run provider and consumer applications, then after a selected init time in the consumer
        // - destruct the runtimes
        // - destruct the proxybuilders
        // - destruct the proxies

        JOYNR_LOG_INFO(logger(), "Exit: Test case 2");

        destroyAllRuntimes();
        destroyAllProxyBuilders();
        destroyAllProxies();
        destroyAllContainers();
        break;
    case testCaseType::TEST_3:
        // Run provider and consumer applications, then after a selected init time in the consumer
        // - destruct the proxybuilders
        // - destruct the runtimes
        // - destruct the proxies

        JOYNR_LOG_INFO(logger(), "Exit: Test case 3");

        destroyAllProxyBuilders();
        destroyAllRuntimes();
        destroyAllProxies();
        destroyAllContainers();
        break;
    default:
        JOYNR_LOG_ERROR(logger(), "Invalid test case: {}", testCase);
        break;
    }
}

void ConsumerTest::unsubscribeFromAll()
{
    for (auto& it_runtime : myRunTimeContainerList) {
        for (auto& it_proxyBuilder : it_runtime.proxyBuilderContainerList) {
            for (auto& it_proxy : it_proxyBuilder.proxyContainerList) {

                // unsubscribe from Broadcast1
                try {
                    it_proxy.proxy->unsubscribeFromBroadcastWithClassParameter1Broadcast(
                            it_proxy.myBroadcastSubscriptionId1);
                } catch (const joynr::exceptions::JoynrRuntimeException& e) {
                    JOYNR_LOG_ERROR(logger(),
                                    "UNSUBSCRIBE from myBroadcastSubscription 1 FAILED: {}",
                                    e.getMessage());
                }

                // unsubscribe from Broadcast2
                try {
                    it_proxy.proxy->unsubscribeFromBroadcastWithClassParameter2Broadcast(
                            it_proxy.myBroadcastSubscriptionId2);
                } catch (const joynr::exceptions::JoynrRuntimeException& e) {
                    JOYNR_LOG_ERROR(logger(),
                                    "UNSUBSCRIBE from myBroadcastSubscription 2 FAILED: {}",
                                    e.getMessage());
                }

                // unsubscribe from selective broadcast 1
                try {
                    it_proxy.proxy
                            ->unsubscribeFromBroadcastSelectiveWithSingleStringParameter1Broadcast(
                                    it_proxy.mySelectiveBroadcastSubscriptionId1);
                } catch (const joynr::exceptions::JoynrRuntimeException& e) {
                    JOYNR_LOG_ERROR(
                            logger(),
                            "UNSUBSCRIBE from mySelectiveBroadcastSubscriptionId 1 FAILED: {}",
                            e.getMessage());
                }

                // unsubscribe from selective broadcast 2
                try {
                    it_proxy.proxy
                            ->unsubscribeFromBroadcastSelectiveWithSingleStringParameter2Broadcast(
                                    it_proxy.mySelectiveBroadcastSubscriptionId2);
                } catch (const joynr::exceptions::JoynrRuntimeException& e) {
                    JOYNR_LOG_ERROR(
                            logger(),
                            "UNSUBSCRIBE from mySelectiveBroadcastSubscriptionId 2 FAILED: {}",
                            e.getMessage());
                }
            }
        }
    }
}

void ConsumerTest::destroyAllRuntimes()
{
    for (auto& it_runtime : myRunTimeContainerList) {

        it_runtime.runtime.reset();
    }
}

void ConsumerTest::destroyAllProxyBuilders()
{
    for (auto& it_runtime : myRunTimeContainerList) {
        for (auto& it_proxyBuilder : it_runtime.proxyBuilderContainerList) {

            it_proxyBuilder.proxyBuilder.reset();
        }
    }
}

void ConsumerTest::destroyAllProxies()
{
    for (auto& it_runtime : myRunTimeContainerList) {
        for (auto& it_proxyBuilder : it_runtime.proxyBuilderContainerList) {
            for (auto& it_proxy : it_proxyBuilder.proxyContainerList) {

                it_proxy.myProxy.reset();
                it_proxy.proxy.reset();
            }
        }
    }
}

void ConsumerTest::destroyAllContainers()
{
    for (auto& it_runtime : myRunTimeContainerList) {
        for (auto& it_proxyBuilder : it_runtime.proxyBuilderContainerList) {

            it_proxyBuilder.proxyContainerList.erase(it_proxyBuilder.proxyContainerList.begin(),
                                                     it_proxyBuilder.proxyContainerList.end());
        }
        it_runtime.proxyBuilderContainerList.erase(it_runtime.proxyBuilderContainerList.begin(),
                                                   it_runtime.proxyBuilderContainerList.end());
    }
    myRunTimeContainerList.erase(myRunTimeContainerList.begin(), myRunTimeContainerList.end());
}
