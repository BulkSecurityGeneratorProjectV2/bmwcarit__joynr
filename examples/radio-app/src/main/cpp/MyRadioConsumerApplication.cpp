/*
 * #%L
 * %%
 * Copyright (C) 2011 - 2013 BMW Car IT GmbH
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */

#include <QFileInfo>

#include "MyRadioHelper.h"
#include "joynr/vehicle/RadioProxy.h"
#include "joynr/JoynrRuntime.h"
#include "joynr/RequestStatus.h"
#include "joynr/ISubscriptionListener.h"
#include "joynr/OnChangeWithKeepAliveSubscriptionQos.h"
#include <cassert>
#include <limits>

using namespace joynr;
using joynr_logging::Logger;
using joynr_logging::Logging;

//------- Run a demonstration ----------------------------------------------------

void runDemo(vehicle::RadioProxy* proxy)
{
    Logger* logger =
            Logging::getInstance()->getLogger("DEMO", "MyRadioConsumerApplication::runDemo");

    try {
        RequestStatus status;
        bool boolResult;
        QString strResult;

        proxy->getIsOn(status, boolResult);
        assert(status.successful());
        MyRadioHelper::prettyLog(
                logger, QString("Is the radio on? : %1").arg(boolResult ? "true" : "false"));

        proxy->setIsOn(status, true);
        assert(status.successful());
        proxy->getIsOn(status, boolResult);
        assert(status.successful());
        MyRadioHelper::prettyLog(
                logger, QString("The radio should be on : %1").arg(boolResult ? "true" : "false"));

        proxy->getCurrentStation(status, strResult);
        assert(status.successful());
        MyRadioHelper::prettyLog(
                logger, QString("The current radio station is : %1").arg(strResult));

        proxy->shuffleStations(status);
        assert(status.successful());
        proxy->getCurrentStation(status, strResult);
        MyRadioHelper::prettyLog(
                logger,
                QString("The current radio station after shuffling is : %1").arg(strResult));

    } catch (JoynrException& e) {
        LOG_FATAL(logger, QString("Caught JOYn exception in runDemo(): %1").arg(e.what()));
    }
}

//------- Subscriptions ----------------------------------------------------------

// A class that listens to messages generated by subscriptions
class RadioStationListener : public ISubscriptionListener<QString>
{
public:
    RadioStationListener()
            : logger(Logging::getInstance()->getLogger(
                      "DEMO",
                      "MyRadioConsumerApplication::RadioStationListener"))
    {
    }

    ~RadioStationListener()
    {
        if (logger)
            delete logger;
    }

    void receive(QString value)
    {
        MyRadioHelper::prettyLog(logger, QString("Received subscription value %1").arg(value));
    }

    void publicationMissed()
    {
        MyRadioHelper::prettyLog(logger, QString("Publication Missed"));
    }

private:
    Logger* logger;
};

// Run a subscription
QString runSubscription(vehicle::RadioProxy* proxy)
{
    Logger* logger = Logging::getInstance()->getLogger(
            "DEMO", "MyRadioConsumerApplication::runSubscription");

    // Set the Quality of Service parameters for the subscription

    // The provider will send a notification whenever the value changes. The number of sent
    // notifications
    // may be limited by the min interval QoS.
    // NOTE: The provider must support on-change notifications in order to use this feature by
    // calling
    //       the <attribute>Changed method of the <interface>AbstractProvider class whenever the
    //       <attribute>
    //       value changes.
    QSharedPointer<OnChangeWithKeepAliveSubscriptionQos> subscriptionQos(
            new OnChangeWithKeepAliveSubscriptionQos());
    // The provider will maintain at least a minimum interval idle time in milliseconds between
    // successive notifications, even if on-change notifications are enabled and the value changes
    // more
    // often. This prevents the consumer from being flooded by updated values. The filtering happens
    // on
    // the provider's side, thus also preventing excessive network traffic.
    subscriptionQos->setMinInterval(5 * 1000);
    // The provider will send notifications every maximum interval in milliseconds, even if the
    // value didn't
    // change. It will send notifications more often if on-change notifications are enabled,
    // the value changes more often, and the minimum interval QoS does not prevent it. The maximum
    // interval
    // can thus be seen as a sort of heart beat.
    subscriptionQos->setMaxInterval(8 * 1000);
    // The provider will send notifications until the end date is reached. The consumer will not
    // receive any
    // notifications (neither value notifications nor missed publication notifications) after
    // this date.
    // setValidity_ms will set the end date to current time millis + validity_ms
    subscriptionQos->setValidity(60 * 1000);
    // Notification messages will be sent with this time-to-live. If a notification message can not
    // be
    // delivered within its TTL, it will be deleted from the system.
    // NOTE: If a notification message is not delivered due to an expired TTL, it might raise a
    //       missed publication notification (depending on the value of the alert interval QoS).
    subscriptionQos->setAlertAfterInterval(10 * 1000);

    // Subscriptions go to a listener object
    QSharedPointer<ISubscriptionListener<QString>> listener(new RadioStationListener());

    // Subscribe to the radio station.
    QString subscriptionId = proxy->subscribeToCurrentStation(listener, subscriptionQos);

    return subscriptionId;
}

//------- Main entry point -------------------------------------------------------

int main(int argc, char* argv[])
{

    // Get a logger
    Logger* logger = Logging::getInstance()->getLogger("DEMO", "MyRadioConsumerApplication");

    // Check the usage
    QString programName(argv[0]);
    if (argc != 2) {
        LOG_ERROR(logger, QString("USAGE: %1 <provider-domain>").arg(programName));
        return 1;
    }

    // Get the provider domain
    QString providerDomain(argv[1]);
    LOG_INFO(logger, QString("Creating proxy for provider on domain \"%1\"").arg(providerDomain));

    // Get the current program directory
    QString dir(QFileInfo(programName).absolutePath());

    // Initialise the JOYn runtime
    QString pathToMessagingSettings(dir + QString("/resources/radio-app-consumer.settings"));
    QString pathToLibJoynrSettings(dir +
                                   QString("/resources/radio-app-consumer.libjoynr.settings"));
    JoynrRuntime* runtime =
            JoynrRuntime::createRuntime(pathToLibJoynrSettings, pathToMessagingSettings);

    // Create proxy builder
    ProxyBuilder<vehicle::RadioProxy>* proxyBuilder =
            runtime->getProxyBuilder<vehicle::RadioProxy>(providerDomain);

    // Messaging Quality of service
    qlonglong qosMsgTtl = 30000;                // Time to live is 30 secs in one direction
    qlonglong qosCacheDataFreshnessMs = 400000; // Only consider data cached for < 400 secs

    // Find the provider with the highest priority set in ProviderQos
    DiscoveryQos discoveryQos;
    // As soon as the discovery QoS is set on the proxy builder, discovery of suitable providers
    // is triggered. If the discovery process does not find matching providers within the
    // arbitration timeout duration it will be terminated and you will get an arbitration exception.
    discoveryQos.setDiscoveryTimeout(40000);
    // Provider entries in the global capabilities directory are cached locally. Discovery will
    // consider entries in this cache valid if they are younger as the max age of cached
    // providers as defined in the QoS. All valid entries will be processed by the arbitrator when
    // searching
    // for and arbitrating the "best" matching provider.
    // NOTE: Valid cache entries might prevent triggering a lookup in the global capabilities
    //       directory. Therefore, not all providers registered with the global capabilities
    //       directory might be taken into account during arbitration.
    discoveryQos.setCacheMaxAge(std::numeric_limits<qint64>::max());
    // The discovery process outputs a list of matching providers. The arbitration strategy then
    // chooses one or more of them to be used by the proxy.
    discoveryQos.setArbitrationStrategy(DiscoveryQos::ArbitrationStrategy::HIGHEST_PRIORITY);

    // Build a proxy
    vehicle::RadioProxy* proxy = proxyBuilder->setRuntimeQos(MessagingQos(qosMsgTtl))
                                         ->setProxyQos(ProxyQos(qosCacheDataFreshnessMs))
                                         ->setCached(false)
                                         ->setDiscoveryQos(discoveryQos)
                                         ->build();

    // Run the demo using the proxy
    runDemo(proxy);

    // Run a short subscription using the proxy
    QString subscriptionId = runSubscription(proxy);

    MyRadioHelper::pressQToContinue();

    // unsubscribe
    proxy->unsubscribeFromCurrentStation(subscriptionId);

    delete proxy;
    delete proxyBuilder;
    delete runtime;
    delete logger;
    return 0;
}
