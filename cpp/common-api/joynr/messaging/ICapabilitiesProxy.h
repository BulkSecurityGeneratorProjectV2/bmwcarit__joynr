/*
* This file was generated by the CommonAPI Generators.
*
*/
#ifndef JOYNR_MESSAGING_I_Capabilities_PROXY_H_
#define JOYNR_MESSAGING_I_Capabilities_PROXY_H_

#include "ICapabilitiesProxyBase.h"

namespace joynr {
namespace messaging {

template <typename ... _AttributeExtensions>
class ICapabilitiesProxy: virtual public ICapabilities, virtual public ICapabilitiesProxyBase, public _AttributeExtensions... {
 public:
    ICapabilitiesProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~ICapabilitiesProxy();




    /**
     * Calls add with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void add(const std::string& domain, const std::string& interfaceName, const std::string& participantId, const types::Types::ProviderQos& qos, const types::Types::EndpointAddressList& endpointAddressList, const types::Types::EndpointAddressBase& messagingStubAddress, const int64_t& timeout_ms, CommonAPI::CallStatus& callStatus);
    /**
     * Calls add with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> addAsync(const std::string& domain, const std::string& interfaceName, const std::string& participantId, const types::Types::ProviderQos& qos, const types::Types::EndpointAddressList& endpointAddressList, const types::Types::EndpointAddressBase& messagingStubAddress, const int64_t& timeout_ms, AddAsyncCallback callback);

    /**
     * Calls addEndPoint with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void addEndPoint(const std::string& participantId, const types::Types::EndpointAddressBase& messagingStubAddress, const int64_t& timeout_ms, CommonAPI::CallStatus& callStatus);
    /**
     * Calls addEndPoint with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> addEndPointAsync(const std::string& participantId, const types::Types::EndpointAddressBase& messagingStubAddress, const int64_t& timeout_ms, AddEndPointAsyncCallback callback);

    /**
     * Calls lookup1 with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void lookup1(const std::string& domain, const std::string& interfaceName, const types::Types::ProviderQosRequirement& qos, const types::Types::DiscoveryQos& discoveryQos, CommonAPI::CallStatus& callStatus, types::Types::CapabilityEntryList& result);
    /**
     * Calls lookup1 with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> lookup1Async(const std::string& domain, const std::string& interfaceName, const types::Types::ProviderQosRequirement& qos, const types::Types::DiscoveryQos& discoveryQos, Lookup1AsyncCallback callback);

    /**
     * Calls lookup2 with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void lookup2(const std::string& participandId, const types::Types::DiscoveryQos& discoveryQos, CommonAPI::CallStatus& callStatus, types::Types::CapabilityEntryList& result);
    /**
     * Calls lookup2 with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> lookup2Async(const std::string& participandId, const types::Types::DiscoveryQos& discoveryQos, Lookup2AsyncCallback callback);

    /**
     * Calls remove with synchronous semantics.
     * 
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     * Synchronous calls are not supported (will block indefinitely) when mainloop integration is used.
     */
    virtual void remove(const std::string& participantId, const int64_t& timeout_ms, CommonAPI::CallStatus& callStatus);
    /**
     * Calls remove with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> removeAsync(const std::string& participantId, const int64_t& timeout_ms, RemoveAsyncCallback callback);

    /// Returns the CommonAPI address of the remote partner this proxy communicates with.
    virtual std::string getAddress() const;

    /// Returns the domain of the remote partner this proxy communicates with.
    virtual const std::string& getDomain() const;

    /// Returns the service ID of the remote partner this proxy communicates with.
    virtual const std::string& getServiceId() const;

    /// Returns the instance ID of the remote partner this proxy communicates with.
    virtual const std::string& getInstanceId() const;

    /// Returns true if the remote partner for this proxy is available.
    virtual bool isAvailable() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<ICapabilitiesProxyBase> delegate_;
};


//
// ICapabilitiesProxy Implementation
//
template <typename ... _AttributeExtensions>
ICapabilitiesProxy<_AttributeExtensions...>::ICapabilitiesProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        delegate_(std::dynamic_pointer_cast<ICapabilitiesProxyBase>(delegate)),
        _AttributeExtensions(*(std::dynamic_pointer_cast<ICapabilitiesProxyBase>(delegate)))... {
}

template <typename ... _AttributeExtensions>
ICapabilitiesProxy<_AttributeExtensions...>::~ICapabilitiesProxy() {
}



template <typename ... _AttributeExtensions>
void ICapabilitiesProxy<_AttributeExtensions...>::add(const std::string& domain, const std::string& interfaceName, const std::string& participantId, const types::Types::ProviderQos& qos, const types::Types::EndpointAddressList& endpointAddressList, const types::Types::EndpointAddressBase& messagingStubAddress, const int64_t& timeout_ms, CommonAPI::CallStatus& callStatus) {
    delegate_->add(domain, interfaceName, participantId, qos, endpointAddressList, messagingStubAddress, timeout_ms, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ICapabilitiesProxy<_AttributeExtensions...>::addAsync(const std::string& domain, const std::string& interfaceName, const std::string& participantId, const types::Types::ProviderQos& qos, const types::Types::EndpointAddressList& endpointAddressList, const types::Types::EndpointAddressBase& messagingStubAddress, const int64_t& timeout_ms, AddAsyncCallback callback) {
    return delegate_->addAsync(domain, interfaceName, participantId, qos, endpointAddressList, messagingStubAddress, timeout_ms, callback);
}

template <typename ... _AttributeExtensions>
void ICapabilitiesProxy<_AttributeExtensions...>::addEndPoint(const std::string& participantId, const types::Types::EndpointAddressBase& messagingStubAddress, const int64_t& timeout_ms, CommonAPI::CallStatus& callStatus) {
    delegate_->addEndPoint(participantId, messagingStubAddress, timeout_ms, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ICapabilitiesProxy<_AttributeExtensions...>::addEndPointAsync(const std::string& participantId, const types::Types::EndpointAddressBase& messagingStubAddress, const int64_t& timeout_ms, AddEndPointAsyncCallback callback) {
    return delegate_->addEndPointAsync(participantId, messagingStubAddress, timeout_ms, callback);
}

template <typename ... _AttributeExtensions>
void ICapabilitiesProxy<_AttributeExtensions...>::lookup1(const std::string& domain, const std::string& interfaceName, const types::Types::ProviderQosRequirement& qos, const types::Types::DiscoveryQos& discoveryQos, CommonAPI::CallStatus& callStatus, types::Types::CapabilityEntryList& result) {
    delegate_->lookup1(domain, interfaceName, qos, discoveryQos, callStatus, result);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ICapabilitiesProxy<_AttributeExtensions...>::lookup1Async(const std::string& domain, const std::string& interfaceName, const types::Types::ProviderQosRequirement& qos, const types::Types::DiscoveryQos& discoveryQos, Lookup1AsyncCallback callback) {
    return delegate_->lookup1Async(domain, interfaceName, qos, discoveryQos, callback);
}

template <typename ... _AttributeExtensions>
void ICapabilitiesProxy<_AttributeExtensions...>::lookup2(const std::string& participandId, const types::Types::DiscoveryQos& discoveryQos, CommonAPI::CallStatus& callStatus, types::Types::CapabilityEntryList& result) {
    delegate_->lookup2(participandId, discoveryQos, callStatus, result);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ICapabilitiesProxy<_AttributeExtensions...>::lookup2Async(const std::string& participandId, const types::Types::DiscoveryQos& discoveryQos, Lookup2AsyncCallback callback) {
    return delegate_->lookup2Async(participandId, discoveryQos, callback);
}

template <typename ... _AttributeExtensions>
void ICapabilitiesProxy<_AttributeExtensions...>::remove(const std::string& participantId, const int64_t& timeout_ms, CommonAPI::CallStatus& callStatus) {
    delegate_->remove(participantId, timeout_ms, callStatus);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> ICapabilitiesProxy<_AttributeExtensions...>::removeAsync(const std::string& participantId, const int64_t& timeout_ms, RemoveAsyncCallback callback) {
    return delegate_->removeAsync(participantId, timeout_ms, callback);
}


template <typename ... _AttributeExtensions>
std::string ICapabilitiesProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
const std::string& ICapabilitiesProxy<_AttributeExtensions...>::getDomain() const {
    return delegate_->getDomain();
}

template <typename ... _AttributeExtensions>
const std::string& ICapabilitiesProxy<_AttributeExtensions...>::getServiceId() const {
    return delegate_->getServiceId();
}

template <typename ... _AttributeExtensions>
const std::string& ICapabilitiesProxy<_AttributeExtensions...>::getInstanceId() const {
    return delegate_->getInstanceId();
}

template <typename ... _AttributeExtensions>
bool ICapabilitiesProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& ICapabilitiesProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& ICapabilitiesProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}

} // namespace messaging
} // namespace joynr



#endif // JOYNR_MESSAGING_I_Capabilities_PROXY_H_
