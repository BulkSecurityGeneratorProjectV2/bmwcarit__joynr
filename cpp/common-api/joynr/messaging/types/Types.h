/*
* This file was generated by the CommonAPI Generators.
*
*/
#ifndef JOYNR_MESSAGING_TYPES_Types_H_
#define JOYNR_MESSAGING_TYPES_Types_H_

#include <CommonAPI/InputStream.h>
#include <CommonAPI/OutputStream.h>
#include <CommonAPI/SerializableStruct.h>
#include <CommonAPI/types.h>
#include <cstdint>
#include <string>
#include <unordered_map>
#include <vector>

namespace joynr {
namespace messaging {
namespace types {

namespace Types {
    struct CustomParameter: CommonAPI::SerializableStruct {
        std::string name;
        std::string value;
    
        CustomParameter() = default;
        CustomParameter(const std::string& name, const std::string& value);
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeStringType();
            typeOutputStream.writeStringType();
        }
    };
    
    typedef std::vector<CustomParameter> CustomParameterList;
    
    enum class ProviderScope: int32_t {
        GLOBAL,
        LOCAL
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct ProviderScopeComparator;
    
    struct ProviderQos: CommonAPI::SerializableStruct {
        CustomParameterList customParameters;
        int8_t version1;
        int64_t priority;
        ProviderScope scope;
        bool supportsOnChangeSubscriptions;
    
        ProviderQos() = default;
        ProviderQos(const CustomParameterList& customParameters, const int8_t& version1, const int64_t& priority, const ProviderScope& scope, const bool& supportsOnChangeSubscriptions);
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeStringType();typeOutputStream.writeStringType();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.writeInt8Type();
            typeOutputStream.writeInt64Type();
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeBoolType();
        }
    };
    
    enum class ArbitrationStrategy: int32_t {
        NOT_SET,
        FIXED_CHANNEL,
        LOCAL_ONLY,
        KEYWORD,
        HIGHEST_PRIORITY
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct ArbitrationStrategyComparator;
    
    enum class DiscoveryScope: int32_t {
        LOCAL_ONLY,
        LOCAL_THEN_GLOBAL,
        LOCAL_AND_GLOBAL,
        GLOBAL_ONLY
    };
    
    // XXX Definition of a comparator still is necessary for GCC 4.4.1, topic is fixed since 4.5.1
    struct DiscoveryScopeComparator;
    
    typedef std::unordered_map<std::string, CustomParameter> CustomParameterMap;
    
    struct DiscoveryQos: CommonAPI::SerializableStruct {
        int64_t discoveryTimeout;
        ArbitrationStrategy arbitrationStrategy;
        int64_t cacheMaxAge;
        DiscoveryScope discoveryScope;
        int64_t retryInterval;
        bool providerMustSupportOnChange;
        CustomParameterMap customParameters;
    
        DiscoveryQos() = default;
        DiscoveryQos(const int64_t& discoveryTimeout, const ArbitrationStrategy& arbitrationStrategy, const int64_t& cacheMaxAge, const DiscoveryScope& discoveryScope, const int64_t& retryInterval, const bool& providerMustSupportOnChange, const CustomParameterMap& customParameters);
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeInt64Type();
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeInt64Type();
            typeOutputStream.writeInt32Type();
            typeOutputStream.writeInt64Type();
            typeOutputStream.writeBoolType();
            typeOutputStream.beginWriteMapType();
            typeOutputStream.writeStringType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeStringType();typeOutputStream.writeStringType();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteMapType();
        }
    };
    
    struct EndpointAddressBase: CommonAPI::SerializableStruct {
        std::string endPointAddress;
    
        EndpointAddressBase() = default;
        EndpointAddressBase(const std::string& endPointAddress);
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeStringType();
        }
    };
    
    typedef std::vector<EndpointAddressBase> EndpointAddressList;
    
    struct ProviderQosRequirement: CommonAPI::SerializableStruct {
        bool notYetImplemented;
    
        ProviderQosRequirement() = default;
        ProviderQosRequirement(const bool& notYetImplemented);
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeBoolType();
        }
    };
    
    struct CapabilityEntry: CommonAPI::SerializableStruct {
        std::string interfaceName;
        std::string domain;
        ProviderQos qos;
        std::string participantId;
        EndpointAddressList endpointAdresses;
        bool global;
    
        CapabilityEntry() = default;
        CapabilityEntry(const std::string& interfaceName, const std::string& domain, const ProviderQos& qos, const std::string& participantId, const EndpointAddressList& endpointAdresses, const bool& global);
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeStringType();
            typeOutputStream.writeStringType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeStringType();typeOutputStream.writeStringType();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();typeOutputStream.writeInt8Type();typeOutputStream.writeInt64Type();typeOutputStream.writeInt32Type();typeOutputStream.writeBoolType();
            typeOutputStream.endWriteStructType();
            typeOutputStream.writeStringType();
            typeOutputStream.beginWriteVectorType();
            typeOutputStream.beginWriteStructType();
            typeOutputStream.writeStringType();
            typeOutputStream.endWriteStructType();
            typeOutputStream.endWriteVectorType();
            typeOutputStream.writeBoolType();
        }
    };
    
    typedef std::vector<CapabilityEntry> CapabilityEntryList;
    
    typedef std::unordered_map<std::string, std::string> JoynrMessageHeader;
    
    struct JoynrMessageQos: CommonAPI::SerializableStruct {
        int64_t ttl;
    
        JoynrMessageQos() = default;
        JoynrMessageQos(const int64_t& ttl);
    
        virtual void readFromInputStream(CommonAPI::InputStream& inputStream);
        virtual void writeToOutputStream(CommonAPI::OutputStream& outputStream) const;
    
        static inline void writeToTypeOutputStream(CommonAPI::TypeOutputStream& typeOutputStream) {
            typeOutputStream.writeInt64Type();
        }
    };
    

bool operator==(const CustomParameter& lhs, const CustomParameter& rhs);
inline bool operator!=(const CustomParameter& lhs, const CustomParameter& rhs) {
    return !(lhs == rhs);
}
inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, ProviderScope& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const ProviderScope& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct ProviderScopeComparator {
    inline bool operator()(const ProviderScope& lhs, const ProviderScope& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

bool operator==(const ProviderQos& lhs, const ProviderQos& rhs);
inline bool operator!=(const ProviderQos& lhs, const ProviderQos& rhs) {
    return !(lhs == rhs);
}
inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, ArbitrationStrategy& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const ArbitrationStrategy& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct ArbitrationStrategyComparator {
    inline bool operator()(const ArbitrationStrategy& lhs, const ArbitrationStrategy& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

inline CommonAPI::InputStream& operator>>(CommonAPI::InputStream& inputStream, DiscoveryScope& enumValue) {
    return inputStream.readEnumValue<int32_t>(enumValue);
}

inline CommonAPI::OutputStream& operator<<(CommonAPI::OutputStream& outputStream, const DiscoveryScope& enumValue) {
    return outputStream.writeEnumValue(static_cast<int32_t>(enumValue));
}

struct DiscoveryScopeComparator {
    inline bool operator()(const DiscoveryScope& lhs, const DiscoveryScope& rhs) const {
        return static_cast<int32_t>(lhs) < static_cast<int32_t>(rhs);
    }
};

bool operator==(const DiscoveryQos& lhs, const DiscoveryQos& rhs);
inline bool operator!=(const DiscoveryQos& lhs, const DiscoveryQos& rhs) {
    return !(lhs == rhs);
}
bool operator==(const EndpointAddressBase& lhs, const EndpointAddressBase& rhs);
inline bool operator!=(const EndpointAddressBase& lhs, const EndpointAddressBase& rhs) {
    return !(lhs == rhs);
}
bool operator==(const ProviderQosRequirement& lhs, const ProviderQosRequirement& rhs);
inline bool operator!=(const ProviderQosRequirement& lhs, const ProviderQosRequirement& rhs) {
    return !(lhs == rhs);
}
bool operator==(const CapabilityEntry& lhs, const CapabilityEntry& rhs);
inline bool operator!=(const CapabilityEntry& lhs, const CapabilityEntry& rhs) {
    return !(lhs == rhs);
}
bool operator==(const JoynrMessageQos& lhs, const JoynrMessageQos& rhs);
inline bool operator!=(const JoynrMessageQos& lhs, const JoynrMessageQos& rhs) {
    return !(lhs == rhs);
}


static inline const char* getTypeCollectionName() {
    return "joynr.messaging.types.Types";
}


} // namespace Types

} // namespace types
} // namespace messaging
} // namespace joynr

namespace CommonAPI {
	
	template<>
	struct BasicTypeWriter<joynr::messaging::types::Types::ProviderScope> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<joynr::messaging::types::Types::ProviderScope> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<joynr::messaging::types::Types::ProviderScope>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<joynr::messaging::types::Types::ProviderScope> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<joynr::messaging::types::Types::ProviderScope>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<joynr::messaging::types::Types::ArbitrationStrategy> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<joynr::messaging::types::Types::ArbitrationStrategy> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<joynr::messaging::types::Types::ArbitrationStrategy>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<joynr::messaging::types::Types::ArbitrationStrategy> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<joynr::messaging::types::Types::ArbitrationStrategy>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	template<>
	struct BasicTypeWriter<joynr::messaging::types::Types::DiscoveryScope> {
	    inline static void writeType (CommonAPI::TypeOutputStream& typeStream) {
	        typeStream.writeInt32EnumType();
	    }
	};
	
	template<>
	struct InputStreamVectorHelper<joynr::messaging::types::Types::DiscoveryScope> {
	    static void beginReadVector(InputStream& inputStream, const std::vector<joynr::messaging::types::Types::DiscoveryScope>& vectorValue) {
	        inputStream.beginReadInt32EnumVector();
	    }
	};
	
	template <>
	struct OutputStreamVectorHelper<joynr::messaging::types::Types::DiscoveryScope> {
	    static void beginWriteVector(OutputStream& outputStream, const std::vector<joynr::messaging::types::Types::DiscoveryScope>& vectorValue) {
	        outputStream.beginWriteInt32EnumVector(vectorValue.size());
	    }
	};
	
}


namespace std {
    template<>
    struct hash<joynr::messaging::types::Types::ProviderScope> {
        inline size_t operator()(const joynr::messaging::types::Types::ProviderScope& providerScope) const {
            return static_cast<int32_t>(providerScope);
        }
    };
    template<>
    struct hash<joynr::messaging::types::Types::ArbitrationStrategy> {
        inline size_t operator()(const joynr::messaging::types::Types::ArbitrationStrategy& arbitrationStrategy) const {
            return static_cast<int32_t>(arbitrationStrategy);
        }
    };
    template<>
    struct hash<joynr::messaging::types::Types::DiscoveryScope> {
        inline size_t operator()(const joynr::messaging::types::Types::DiscoveryScope& discoveryScope) const {
            return static_cast<int32_t>(discoveryScope);
        }
    };
}

#endif // JOYNR_MESSAGING_TYPES_Types_H_
